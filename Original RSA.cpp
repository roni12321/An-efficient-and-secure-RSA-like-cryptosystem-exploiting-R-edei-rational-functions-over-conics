/*
* Made by Roni Belkin & Asaf Yusufov
* To use GMP library please install the library from http://rstudio-pubs-static.s3.amazonaws.com/493124_a46782f9253a4b8193595b6b2a037d58.html#15_on_ubuntu
* GMP library official site - https://gmplib.org
*/

#include <stdlib.h> //for srand,rand
#include <time.h>   //for time
#include <gmpxx.h>  //for big numbers
#include <cstdlib>
#include <ctime>
#include <iostream> // i/o
#include <chrono>   //for measure time
#include <iomanip>

using namespace std::chrono;
using namespace std;

void generatePublicKey(mpz_t e,mpz_t phi,gmp_randstate_t state){/* Define 1 < e < φ */
    mpz_t one,zero,gcdResult; /* Declaration of function local parameters */
    /* Initialize the parameters */
    mpz_init(one);
    mpz_init(gcdResult);
    mpz_init(zero);/* Init zero to be 0 */
    mpz_add_ui(one, one, 1); /* define the parameter one to be with value 1 by adding */
    
    do{
        mpz_urandomm(e,state,phi); /* Generate a uniformly distributed random integer */
        mpz_gcd (gcdResult, e, phi); /* calculate the gcd(e,phi) and put the result into "gcdResult" */
    } /* The while checks if:
       * (1) "e" is not equals to zero.
       * (2) "e" is not equals to one.
       * (3) Gcd(e,phi) is not equals to zero.
       */
    while((mpz_cmp(e,zero) == 0)||(mpz_cmp(e,one) == 0)||(mpz_cmp(gcdResult,one) != 0));
    /* Clear the parameters that used in the function */
    mpz_clear(zero);
    mpz_clear(one);
}


int main() {
 cout << "==============================================================================================================================\n\n";    cout << "The Original RSA start running...\n\n";
 cout << "==============================================================================================================================\n\n";    auto start = high_resolution_clock::now(); // start measure time for all program
    srand((unsigned int)time(NULL)); //cast for unsigned int for not loose values
    unsigned long long int seed;
    seed = (unsigned long long int)rand() % 100 + 1; /* Define the limit of the random number */
    gmp_randstate_t state;  /* Variable state for gmp_randinit, must be initialized */
    /* Define the parameters of the RSA algorithm */
    mpz_t p, q, N,phi,p_1,q_1,e,d,Mx,My,Cx,Cy,MxAfterDecryption,MyAfterDecryption;
    mp_bitcnt_t n;
    /* Initialize the RSA parameters */
    mpz_init(p);
    mpz_init(q);
    mpz_init(N);
    mpz_init(e);
    mpz_init(d);
    mpz_init(phi);
    mpz_init(p_1);
    mpz_init(q_1);
    mpz_init(Mx);
    mpz_init(My);
    mpz_init(Cx);
    mpz_init(Cy);
    mpz_init(MxAfterDecryption);
    mpz_init(MyAfterDecryption);
    n = 64; /* Number of bits for the number in range 0 to (2^n)-1, inclusive */
    gmp_randinit_default(state);    /* Initialize state with a default algorithm */
    gmp_randseed_ui ( state, seed ); /* Set an initial seed value into state */
    /* The size of a seed determines how many different sequences of random numbers that it’s possible to generate */
    while (true)
    {
        mpz_urandomb(p, state, n);  // Generate a uniformly distributed random integer
        if (mpz_probab_prime_p(p, 50) == 2) // Determine whether p is prime. Return 2 if p is definitely prime
            break;
    }
    while (true)
    {
        mpz_urandomb(q, state, n);  // Generate a uniformly distributed random integer
        if (mpz_probab_prime_p(q, 50) == 2) // Determine whether q is prime. Return 2 if q is definitely prime
            break;
    }
    mpz_mul(N, p, q);    /* Set N to p times q */
    gmp_printf("p = %Zd, ", p);
    gmp_printf("q = %Zd, ", q);
    gmp_printf("N = %Zd\n\n", N);
 cout << "==============================================================================================================================\n\n";    mpz_sub_ui(p_1,p,1);/* calculate p-1 */
    mpz_sub_ui(q_1,q,1);/* calculate q-1 */
    mpz_mul(phi, p_1, q_1);/* calculate phi */
    //public key
    //e stands for encryption
    generatePublicKey(e,phi,state); /* generate the parameter "e" */
    if(mpz_invert(d, e, phi)==0){ /* choosing d such that it satisfies d*e = 1 mod phi */
        cout <<"There NO inverse parameter for e\n";
        return 0;
    }
    gmp_printf("e = %Zd, ", e);
    gmp_printf("d = %Zd\n\n", d);
 cout << "==============================================================================================================================\n\n";    /* define the plain values */
    mpz_set_ui(Mx, 83); /* Set the first part of message */
    mpz_set_ui(My, 135); /* Set the second part of message */
    gmp_printf("The point values are: Mx = %Zd, My = %Zd\n\n",Mx,My);
 cout << "==============================================================================================================================\n\n";    //Encrypt the plain
    auto start1 = high_resolution_clock::now(); // start measure time for encryption
    mpz_powm_sec (Cx, Mx, e, N); /* Encrypt the first part of message */
    mpz_powm_sec (Cy, My, e, N); /* Encrypt the second part of message */
    auto stop1 = high_resolution_clock::now(); // stop measure time for encryption
    auto duration1 = duration_cast<nanoseconds>(stop1 - start1); // time measurement end - start
    gmp_printf("The encrypted point values are: Cx = %Zd, Cy = %Zd\n\n",Cx,Cy);
 cout << "==============================================================================================================================\n\n";    // end of encryption
    // Decrypt the cipher
    auto start2 = high_resolution_clock::now(); // start measure time for decryption
    mpz_powm_sec(MxAfterDecryption,Cx,d,N); /* Decrypt the first part of message */
    mpz_powm_sec(MyAfterDecryption,Cy,d,N); /* Decrypt the second part of message */
    auto stop2 = high_resolution_clock::now(); // stop measure time for encryption
    auto duration2 = duration_cast<nanoseconds>(stop2 - start2); // time measurement end - start
    gmp_printf("The decrypted point values are: Mx = %Zd, My = %Zd\n\n",MxAfterDecryption,MyAfterDecryption);
    cout << "==============================================================================================================================\n\n";
    //clear all parameters that decleared in the main
    mpz_clear(p);
    mpz_clear(q);
    mpz_clear(N);
    mpz_clear(e);
    mpz_clear(d);
    mpz_clear(phi);
    mpz_clear(p_1);
    mpz_clear(q_1);
    mpz_clear(Mx);
    mpz_clear(My);
    mpz_clear(Cx);
    mpz_clear(Cy);
    mpz_clear(MxAfterDecryption);
    mpz_clear(MyAfterDecryption);
    auto stop = high_resolution_clock::now(); // stop measure time
    auto duration = duration_cast<nanoseconds>(stop - start); // time measurement end - start
    cout << "Time for encryption process : "  <<fixed << setprecision(6) <<(double)duration1.count() /(1000000000)<<" [ Seconds ]\n";
    cout << "Time for decryption process : "  <<fixed << setprecision(6) <<(double)duration2.count() /(1000000000)<< " [ Seconds ]\n";
    cout << "Total time for orignal RSA : "  <<fixed << setprecision(6) <<(double)duration.count() /(1000000000)<<" [ Seconds ]\n\n";
 cout << "==============================================================================================================================\n\n";    cout << "The Original RSA has finish the running.\n\n";
 cout << "==============================================================================================================================\n\n";    return 0;
}

